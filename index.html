<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Arix Signature Tree | Standalone Experience</title>
    
    <!-- Tailwind CSS Play CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Babel Standalone for JSX compilation in browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Inter:wght@300;400;600&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #021a12;
            -webkit-user-select: none;
            user-select: none;
        }
        .font-cinzel { font-family: 'Cinzel', serif; }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        canvas { touch-action: none; }
    </style>

    <!-- Optimized Import Map to enforce singletons for React, Three, and Fiber across all plugins -->
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@19.0.0",
        "react-dom": "https://esm.sh/react-dom@19.0.0",
        "react-dom/client": "https://esm.sh/react-dom@19.0.0/client",
        "three": "https://esm.sh/three@0.170.0",
        "@react-three/fiber": "https://esm.sh/@react-three/fiber@9.0.0?deps=react@19.0.0,three@0.170.0",
        "@react-three/drei": "https://esm.sh/@react-three/drei@10.0.0?deps=react@19.0.0,three@0.170.0,@react-three/fiber@9.0.0",
        "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@3.0.4?deps=react@19.0.0,three@0.170.0,@react-three/fiber@9.0.0"
      }
    }
    </script>
<link rel="stylesheet" href="/index.css">
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import * as React from 'react';
        import { useState, useMemo, useRef, Suspense, useEffect } from 'react';
        import ReactDOM from 'react-dom/client';
        import * as THREE from 'three';
        import { Canvas, useFrame } from '@react-three/fiber';
        import { OrbitControls, Environment, Float } from '@react-three/drei';
        import { Bloom, EffectComposer, Vignette, ChromaticAberration, Noise } from '@react-three/postprocessing';

        // --- CONSTANTS ---
        const MorphState = {
            SCATTERED: 'SCATTERED',
            TREE_SHAPE: 'TREE_SHAPE'
        };

        const COLORS = {
            EMERALD_DEEP: '#0a1a15',
            EMERALD_BRIGHT: '#145c44',
            GOLD_METAL: '#d4af37',
            GOLD_SHINE: '#f4e1a1',
            WHITE_GLOW: '#fffaf0',
            RUBY_RED: '#8b1a1a',
            RUBY_BRIGHT: '#c04a4a'
        };

        const CONFIG = {
            PARTICLE_COUNT: 1800,
            ORNAMENT_COUNT: 120,
            GIFT_COUNT: 150,
            STAR_COUNT: 80,
            LIGHT_COUNT: 180,
            TREE_HEIGHT: 10.0,
            TREE_RADIUS: 4.2,
            SCATTER_RADIUS: 16,
            ANIMATION_SPEED: 0.04
        };

        // --- SHADERS ---
        const foliageVertexShader = `
            uniform float uTime;
            uniform float uProgress;
            attribute vec3 aTreePos;
            attribute vec3 aScatterPos;
            attribute float aScale;
            varying float vHighlight;
            varying float vRandom;

            float hash(float n) { return fract(sin(n) * 43758.5453123); }

            void main() {
                vRandom = hash(aScale * 100.0);
                vec3 mixedPos = mix(aScatterPos, aTreePos, uProgress);
                float jitter = sin(uTime * 2.0 + vRandom * 10.0) * 0.02 * uProgress;
                mixedPos += jitter;
                vec4 mvPosition = modelViewMatrix * vec4(mixedPos, 1.0);
                float baseSize = 260.0; 
                gl_PointSize = (baseSize * aScale) * (1.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
                vHighlight = smoothstep(-1.0, 1.0, sin(aTreePos.y * 1.5 + uTime * 1.0));
            }
        `;

        const foliageFragmentShader = `
            varying float vHighlight;
            varying float vRandom;
            uniform vec3 uEmerald;
            uniform vec3 uGold;

            void main() {
                vec2 cxy = 2.0 * gl_PointCoord - 1.0;
                float diamond = abs(cxy.x) + abs(cxy.y);
                if (diamond > 1.0) discard;
                float mask = smoothstep(1.0, 0.7, diamond); 
                vec3 baseColor = mix(uEmerald * 1.2, uGold * 0.7, vRandom * 0.4);
                vec3 color = mix(baseColor, uGold * 1.3, vHighlight * 0.4);
                gl_FragColor = vec4(color * (1.0 + vHighlight * 0.2), mask * 0.99);
            }
        `;

        // --- COMPONENTS ---

        const FoliageLayer = ({ morphState }) => {
            const pointsRef = useRef();
            const targetProgress = useRef(0);
            const currentProgress = useRef(0);

            const attributes = useMemo(() => {
                const treePositions = new Float32Array(CONFIG.PARTICLE_COUNT * 3);
                const scatterPositions = new Float32Array(CONFIG.PARTICLE_COUNT * 3);
                const scales = new Float32Array(CONFIG.PARTICLE_COUNT);

                for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) {
                    const h = Math.random() * CONFIG.TREE_HEIGHT;
                    const radiusAtH = (CONFIG.TREE_RADIUS * (CONFIG.TREE_HEIGHT - h)) / CONFIG.TREE_HEIGHT;
                    const angle = Math.random() * Math.PI * 2;
                    const r = Math.pow(Math.random(), 0.9) * radiusAtH;
                    treePositions[i * 3] = Math.cos(angle) * r;
                    treePositions[i * 3 + 1] = h;
                    treePositions[i * 3 + 2] = Math.sin(angle) * r;

                    const dist = 7 + Math.random() * CONFIG.SCATTER_RADIUS;
                    const phi = Math.random() * Math.PI * 2;
                    const theta = Math.random() * Math.PI;
                    scatterPositions[i * 3] = dist * Math.sin(theta) * Math.cos(phi);
                    scatterPositions[i * 3 + 1] = dist * Math.sin(theta) * Math.sin(phi) + 5;
                    scatterPositions[i * 3 + 2] = dist * Math.cos(theta);
                    scales[i] = 0.5 + Math.random() * 1.0;
                }
                return { treePositions, scatterPositions, scales };
            }, []);

            const uniforms = useMemo(() => ({
                uTime: { value: 0 },
                uProgress: { value: 0 },
                uEmerald: { value: new THREE.Color(COLORS.EMERALD_BRIGHT) },
                uGold: { value: new THREE.Color(COLORS.GOLD_METAL) }
            }), []);

            useFrame((state, delta) => {
                if (pointsRef.current) {
                    targetProgress.current = morphState === MorphState.TREE_SHAPE ? 1 : 0;
                    currentProgress.current = THREE.MathUtils.lerp(currentProgress.current, targetProgress.current, delta * 2.0);
                    pointsRef.current.material.uniforms.uProgress.value = currentProgress.current;
                    pointsRef.current.material.uniforms.uTime.value = state.clock.elapsedTime;
                }
            });

            return (
                <points ref={pointsRef}>
                    <bufferGeometry>
                        <bufferAttribute attach="attributes-position" count={CONFIG.PARTICLE_COUNT} array={attributes.scatterPositions} itemSize={3} />
                        <bufferAttribute attach="attributes-aTreePos" count={CONFIG.PARTICLE_COUNT} array={attributes.treePositions} itemSize={3} />
                        <bufferAttribute attach="attributes-aScatterPos" count={CONFIG.PARTICLE_COUNT} array={attributes.scatterPositions} itemSize={3} />
                        <bufferAttribute attach="attributes-aScale" count={CONFIG.PARTICLE_COUNT} array={attributes.scales} itemSize={1} />
                    </bufferGeometry>
                    <shaderMaterial 
                        vertexShader={foliageVertexShader}
                        fragmentShader={foliageFragmentShader}
                        uniforms={uniforms}
                        transparent
                        depthWrite={false}
                        blending={THREE.AdditiveBlending}
                    />
                </points>
            );
        };

        const OrnamentSystem = ({ morphState }) => {
            const baubleRef = useRef();
            const giftRef = useRef();
            const starRef = useRef();
            const lightRef = useRef();
            const topStarRef = useRef();
            const progressRef = useRef(0);
            
            const tempObject = useMemo(() => new THREE.Object3D(), []);

            const starGeometry = useMemo(() => {
                const shape = new THREE.Shape();
                const points = 5;
                const outerRadius = 1;
                const innerRadius = 0.45;
                for (let i = 0; i < points * 2; i++) {
                    const radius = i % 2 === 0 ? outerRadius : innerRadius;
                    const angle = (i * Math.PI) / points - Math.PI / 2;
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    if (i === 0) shape.moveTo(x, y);
                    else shape.lineTo(x, y);
                }
                shape.closePath();
                return new THREE.ExtrudeGeometry(shape, { depth: 0.3, bevelEnabled: true, bevelThickness: 0.1, bevelSize: 0.1 });
            }, []);

            const data = useMemo(() => {
                const baubles = [];
                const gifts = [];
                const stars = [];
                const lights = [];

                const getTreePos = (hRange, rFactor = 1.0, isCore = false) => {
                    const h = hRange[0] + Math.random() * (hRange[1] - hRange[0]);
                    const radiusAtH = (CONFIG.TREE_RADIUS * (CONFIG.TREE_HEIGHT - h)) / CONFIG.TREE_HEIGHT;
                    const angle = Math.random() * Math.PI * 2;
                    const r = isCore ? (Math.pow(Math.random(), 0.6) * radiusAtH) : (radiusAtH * rFactor);
                    return new THREE.Vector3(Math.cos(angle) * r, h, Math.sin(angle) * r);
                };

                const getScatterPos = () => {
                    return new THREE.Vector3().setFromSphericalCoords(
                        7 + Math.random() * CONFIG.SCATTER_RADIUS,
                        Math.random() * Math.PI,
                        Math.random() * Math.PI * 2
                    ).add(new THREE.Vector3(0, 5, 0));
                };

                for (let i = 0; i < CONFIG.GIFT_COUNT; i++) {
                    gifts.push({
                        treePos: getTreePos([0.1, CONFIG.TREE_HEIGHT * 0.85], 0.95, true),
                        scatterPos: getScatterPos(),
                        scale: 0.18 + Math.random() * 0.28,
                        rotation: new THREE.Euler(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI),
                        weight: 3.0,
                        phase: Math.random() * Math.PI * 2,
                        color: new THREE.Color(Math.random() > 0.5 ? COLORS.RUBY_RED : COLORS.EMERALD_BRIGHT)
                    });
                }

                for (let i = 0; i < CONFIG.ORNAMENT_COUNT; i++) {
                    baubles.push({ 
                        treePos: getTreePos([1.0, CONFIG.TREE_HEIGHT - 0.5], 1.04), 
                        scatterPos: getScatterPos(), 
                        scale: 0.1 + Math.random() * 0.12, 
                        rotation: new THREE.Euler(Math.random(), Math.random(), Math.random()),
                        weight: 1.2,
                        phase: Math.random() * Math.PI * 2
                    });
                }

                for (let i = 0; i < CONFIG.STAR_COUNT; i++) {
                    stars.push({
                        treePos: getTreePos([2.0, CONFIG.TREE_HEIGHT], 1.06),
                        scatterPos: getScatterPos(),
                        scale: 0.08 + Math.random() * 0.15,
                        rotation: new THREE.Euler(Math.random(), Math.random(), Math.random()),
                        weight: 0.8,
                        phase: Math.random() * Math.PI * 2,
                        color: new THREE.Color(Math.random() > 0.7 ? COLORS.RUBY_BRIGHT : COLORS.GOLD_SHINE)
                    });
                }

                for (let i = 0; i < CONFIG.LIGHT_COUNT; i++) {
                    lights.push({
                        treePos: getTreePos([0.5, CONFIG.TREE_HEIGHT - 0.2], 0.92, true),
                        scatterPos: getScatterPos(),
                        scale: 0.05 + Math.random() * 0.06,
                        weight: 0.4,
                        phase: Math.random() * Math.PI * 2
                    });
                }
                return { baubles, gifts, stars, lights };
            }, []);

            const topStarData = useMemo(() => ({
                treePos: new THREE.Vector3(0, CONFIG.TREE_HEIGHT + 0.35, 0),
                scatterPos: new THREE.Vector3(0, 18, 0),
                scale: 0.6
            }), []);

            useFrame((state, delta) => {
                const target = morphState === MorphState.TREE_SHAPE ? 1 : 0;
                progressRef.current = THREE.MathUtils.lerp(progressRef.current, target, delta * 1.8);
                const p = progressRef.current;
                const time = state.clock.elapsedTime;

                if (topStarRef.current) {
                    const pos = new THREE.Vector3().lerpVectors(topStarData.scatterPos, topStarData.treePos, p);
                    if (p < 0.95) {
                        pos.y += Math.sin(time * 0.6) * 1.5 * (1 - p);
                        pos.x += Math.cos(time * 0.4) * 1.5 * (1 - p);
                    }
                    topStarRef.current.position.copy(pos);
                    topStarRef.current.rotation.y = time * 0.7;
                    topStarRef.current.scale.setScalar(topStarData.scale * p + 0.001);
                }

                const updateInstances = (mesh, items, isLight = false) => {
                    if (!mesh) return;
                    items.forEach((item, i) => {
                        const pos = new THREE.Vector3().lerpVectors(item.scatterPos, item.treePos, p);
                        const driftAmp = (1 - p) * (1.8 / item.weight);
                        const driftSpeed = 0.8 / item.weight;
                        pos.x += Math.sin(time * driftSpeed + item.phase) * 0.3 * driftAmp;
                        pos.y += Math.cos(time * driftSpeed * 0.8 + item.phase) * 0.4 * driftAmp;
                        pos.z += Math.sin(time * driftSpeed * 1.1 + item.phase) * 0.3 * driftAmp;
                        tempObject.position.copy(pos);
                        tempObject.scale.setScalar(item.scale);
                        if (item.rotation) {
                            const rotSpeed = isLight ? 0.1 : (1.5 / item.weight);
                            tempObject.rotation.set(item.rotation.x + time * rotSpeed * (1 - p), item.rotation.y + time * (rotSpeed * 0.5), item.rotation.z);
                        }
                        tempObject.updateMatrix();
                        mesh.setMatrixAt(i, tempObject.matrix);
                        if (item.color) mesh.setColorAt(i, item.color);
                    });
                    mesh.instanceMatrix.needsUpdate = true;
                    if (mesh.instanceColor) mesh.instanceColor.needsUpdate = true;
                };

                updateInstances(baubleRef.current, data.baubles);
                updateInstances(giftRef.current, data.gifts);
                updateInstances(starRef.current, data.stars);
                updateInstances(lightRef.current, data.lights, true);
            });

            return (
                <group>
                    <mesh ref={topStarRef} geometry={starGeometry}>
                        <meshStandardMaterial color="#ffd700" emissive="#ffae00" emissiveIntensity={2.5} metalness={1.0} roughness={0.1} />
                        <pointLight intensity={2.0} distance={7} color="#ffd700" />
                    </mesh>
                    <instancedMesh ref={giftRef} args={[null, null, CONFIG.GIFT_COUNT]} castShadow>
                        <boxGeometry args={[1, 1, 1]} />
                        <meshStandardMaterial metalness={0.5} roughness={0.2} envMapIntensity={1.2} />
                    </instancedMesh>
                    <instancedMesh ref={baubleRef} args={[null, null, CONFIG.ORNAMENT_COUNT]} castShadow>
                        <sphereGeometry args={[1, 32, 32]} />
                        <meshStandardMaterial metalness={0.95} roughness={0.05} color={COLORS.GOLD_METAL} emissive={COLORS.GOLD_METAL} emissiveIntensity={0.15} />
                    </instancedMesh>
                    <instancedMesh ref={starRef} args={[null, null, CONFIG.STAR_COUNT]} castShadow>
                        <octahedronGeometry args={[1, 0]} />
                        <meshStandardMaterial metalness={0.8} roughness={0.1} envMapIntensity={1.8} />
                    </instancedMesh>
                    <instancedMesh ref={lightRef} args={[null, null, CONFIG.LIGHT_COUNT]}>
                        <sphereGeometry args={[1, 12, 12]} />
                        <meshStandardMaterial color={COLORS.WHITE_GLOW} emissive={COLORS.GOLD_SHINE} emissiveIntensity={3.5} transparent opacity={0.95} />
                    </instancedMesh>
                </group>
            );
        };

        const Experience = ({ state }) => {
            return (
                <Suspense fallback={null}>
                    <color attach="background" args={[COLORS.EMERALD_DEEP]} />
                    <OrbitControls 
                        enablePan={false} 
                        minDistance={5} 
                        maxDistance={30}
                        autoRotate={state === MorphState.TREE_SHAPE}
                        autoRotateSpeed={0.5}
                        makeDefault
                    />
                    <ambientLight intensity={0.8} />
                    <spotLight position={[15, 20, 15]} angle={0.4} penumbra={1} intensity={1.5} castShadow color={COLORS.GOLD_SHINE} />
                    <pointLight position={[-10, 5, -10]} intensity={0.8} color={COLORS.RUBY_BRIGHT} />
                    <pointLight position={[5, 10, 5]} intensity={1.2} color={COLORS.GOLD_SHINE} />
                    <Environment preset="studio" />
                    <Float speed={1.5} rotationIntensity={0.2} floatIntensity={0.4}>
                        <group position={[0, -4.5, 0]}>
                            <FoliageLayer morphState={state} />
                            <OrnamentSystem morphState={state} />
                        </group>
                    </Float>
                    <EffectComposer disableNormalPass>
                        <Bloom luminanceThreshold={0.8} mipmapBlur intensity={0.7} radius={0.4} />
                        <Vignette eskil={false} offset={0.2} darkness={0.7} />
                        <ChromaticAberration offset={[0.0005, 0.0005]} />
                        <Noise opacity={0.01} />
                    </EffectComposer>
                </Suspense>
            );
        };

        const OverlayUI = ({ currentState, onToggle }) => {
            return (
                <div className="absolute inset-0 pointer-events-none flex flex-col justify-between p-8 md:p-12 z-10">
                    <header className="flex justify-between items-start animate-[fadeIn_1s_ease-out]">
                        <div className="flex flex-col">
                            <h1 className="text-4xl md:text-6xl font-cinzel tracking-[0.1em] text-[#d4af37] drop-shadow-[0_2px_10px_rgba(212,175,55,0.3)]">ARIX</h1>
                            <p className="text-xs md:text-sm tracking-[0.3em] uppercase text-[#fffaf0]/80 font-medium mt-2">Signature Serenity</p>
                        </div>
                        <div className="hidden md:block text-right">
                            <p className="text-[10px] uppercase tracking-[0.2em] text-[#d4af37]">PRIVATE COLLECTION</p>
                            <div className="w-full h-[1px] bg-[#d4af37]/20 my-1" />
                            <p className="text-[10px] uppercase tracking-widest text-[#fffaf0]/40">Soft Construct</p>
                        </div>
                    </header>
                    {currentState === MorphState.SCATTERED && (
                        <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-center transition-all duration-700">
                            <p className="text-[#f4e1a1] font-cinzel text-xl md:text-2xl animate-pulse tracking-[0.4em] uppercase opacity-70">Celestial Warmth</p>
                        </div>
                    )}
                    <footer className="flex flex-col md:flex-row justify-between items-end gap-6 pointer-events-auto">
                        <div className="max-w-xs space-y-2 mb-4 md:mb-0">
                            <h2 className="text-[#d4af37] font-cinzel text-xl uppercase tracking-wider">
                                {currentState === MorphState.TREE_SHAPE ? 'Grand Synthesis' : 'Deconstructed'}
                            </h2>
                            <p className="text-[#fffaf0]/70 text-[11px] font-normal leading-relaxed">
                                {currentState === MorphState.TREE_SHAPE 
                                    ? 'An elegant fusion of moss emerald, warm ruby, and champagne gold forming a monolithic festive spire.'
                                    : 'The structural core dissolved into a gentle nebula of warm fragments and soft light.'}
                            </p>
                        </div>
                        <button 
                            onClick={onToggle} 
                            className="group relative px-10 py-4 bg-white/5 border border-[#d4af37]/40 backdrop-blur-md overflow-hidden transition-all hover:border-[#d4af37] hover:bg-white/10 active:scale-95"
                        >
                            <div className="absolute inset-0 translate-x-[-100%] group-hover:translate-x-[100%] transition-transform duration-1000 bg-gradient-to-r from-transparent via-[#d4af37]/20 to-transparent" />
                            <span className="relative text-[#d4af37] font-cinzel text-sm font-bold tracking-[0.2em] uppercase">
                                {currentState === MorphState.TREE_SHAPE ? 'Dissolve' : 'Assemble'}
                            </span>
                        </button>
                    </footer>
                    <div className="absolute top-4 left-4 w-12 h-12 border-t-2 border-l-2 border-[#d4af37]/20" />
                    <div className="absolute top-4 right-4 w-12 h-12 border-t-2 border-r-2 border-[#d4af37]/20" />
                    <div className="absolute bottom-4 left-4 w-12 h-12 border-b-2 border-l-2 border-[#d4af37]/20" />
                    <div className="absolute bottom-4 right-4 w-12 h-12 border-b-2 border-r-2 border-[#d4af37]/20" />
                </div>
            );
        };

        const App = () => {
            const [state, setState] = useState(MorphState.SCATTERED);
            const toggleState = () => setState(prev => prev === MorphState.SCATTERED ? MorphState.TREE_SHAPE : MorphState.SCATTERED);

            return (
                <div className="relative w-full h-screen bg-[#021a12]">
                    <Canvas
                        shadows
                        camera={{ position: [0, 5, 15], fov: 45 }}
                        gl={{ antialias: true, powerPreference: "high-performance" }}
                    >
                        <Experience state={state} />
                    </Canvas>
                    <OverlayUI currentState={state} onToggle={toggleState} />
                    <div className="pointer-events-none fixed inset-0 bg-[radial-gradient(circle,transparent_20%,black_150%)] opacity-50 shadow-[inset_0_0_150px_rgba(0,0,0,0.8)]" />
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>